var E={},J=(R,x,P)=>(E.__chunk_535=(U,A,b)=>{"use strict";function i(t){let e=new Uint8Array(t.length);for(let r=0;r<t.length;r++)e[r]=t.charCodeAt(r);return e}b.d(A,{b9:()=>N,FA:()=>v,_H:()=>D});function g(t){return btoa(String.fromCharCode(...new TextEncoder().encode(t))).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function m(t){return i(atob(t.replace(/-+(BEGIN|END).*/g,"").replace(/\s/g,"")))}async function C(t,e,r){return await crypto.subtle.importKey("raw",i(t),e,!0,r)}async function H(t,e,r){return await crypto.subtle.importKey("jwk",t,e,!0,r)}async function _(t,e,r){return await crypto.subtle.importKey("spki",m(t),e,!0,r)}async function k(t,e,r){return await crypto.subtle.importKey("pkcs8",m(t),e,!0,r)}async function d(t,e,r){if(typeof t=="object")return H(t,e,r);if(typeof t!="string")throw Error("Unsupported key type!");return t.includes("PUBLIC")?_(t,e,r):t.includes("PRIVATE")?k(t,e,r):C(t,e,r)}function S(t){let e=Array.from(atob(t),r=>r.charCodeAt(0));return JSON.parse(new TextDecoder("utf-8").decode(new Uint8Array(e)))}if(typeof crypto>"u"||!crypto.subtle)throw Error("SubtleCrypto not supported!");var w={none:{name:"none"},ES256:{name:"ECDSA",namedCurve:"P-256",hash:{name:"SHA-256"}},ES384:{name:"ECDSA",namedCurve:"P-384",hash:{name:"SHA-384"}},ES512:{name:"ECDSA",namedCurve:"P-521",hash:{name:"SHA-512"}},HS256:{name:"HMAC",hash:{name:"SHA-256"}},HS384:{name:"HMAC",hash:{name:"SHA-384"}},HS512:{name:"HMAC",hash:{name:"SHA-512"}},RS256:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},RS384:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-384"}},RS512:{name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-512"}}};async function T(t,e,r="HS256"){if(typeof r=="string"&&(r={algorithm:r}),r={algorithm:"HS256",header:{typ:"JWT",...r.header??{}},...r},!t||typeof t!="object")throw Error("payload must be an object");if(r.algorithm!=="none"&&(!e||typeof e!="string"&&typeof e!="object"))throw Error("secret must be a string, a JWK object or a CryptoKey object");if(typeof r.algorithm!="string")throw Error("options.algorithm must be a string");let o=w[r.algorithm];if(!o)throw Error("algorithm not found");t.iat||(t.iat=Math.floor(Date.now()/1e3));let a=`${g(JSON.stringify({...r.header,alg:r.algorithm}))}.${g(JSON.stringify(t))}`;if(r.algorithm==="none")return a;let s=e instanceof CryptoKey?e:await d(e,o,["sign"]),p=await crypto.subtle.sign(o,s,i(a));return`${a}.${btoa(function(h){let f="";for(let l=0;l<h.byteLength;l++)f+=String.fromCharCode(h[l]);return f}(new Uint8Array(p))).replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}`}async function j(t,e,r="HS256"){var o,a,s;if(typeof r=="string"&&(r={algorithm:r}),r={algorithm:"HS256",clockTolerance:0,throwError:!1,...r},typeof t!="string")throw Error("token must be a string");if(r.algorithm!=="none"&&typeof e!="string"&&typeof e!="object")throw Error("secret must be a string, a JWK object or a CryptoKey object");if(typeof r.algorithm!="string")throw Error("options.algorithm must be a string");let p=t.split(".",3);if(p.length<2)throw Error("token must consist of 2 or more parts");let[h,f,l]=p,c=w[r.algorithm];if(!c)throw Error("algorithm not found");let n={header:S((o=t).split(".")[0].replace(/-/g,"+").replace(/_/g,"/")),payload:S(o.split(".")[1].replace(/-/g,"+").replace(/_/g,"/"))};try{if(n.header?.alg!==r.algorithm)throw Error("INVALID_SIGNATURE");if(n.payload){let y=Math.floor(Date.now()/1e3);if(n.payload.nbf&&n.payload.nbf>y&&n.payload.nbf-y>(r.clockTolerance??0))throw Error("NOT_YET_VALID");if(n.payload.exp&&n.payload.exp<=y&&y-n.payload.exp>(r.clockTolerance??0))throw Error("EXPIRED")}if(c.name==="none")return n;let u=e instanceof CryptoKey?e:await d(e,c,["verify"]);if(!await crypto.subtle.verify(c,u,(s=l,i(atob(s.replace(/-/g,"+").replace(/_/g,"/").replace(/\s/g,"")))),(a=`${h}.${f}`,i(a))))throw Error("INVALID_SIGNATURE");return n}catch(u){if(r.throwError)throw u;return}}async function v(t,e){return await T(t,e)}async function I(t,e){try{return await j(t,e)}catch{throw Error("Invalid token")}}async function K(t){let e=new TextEncoder().encode(t);return Array.from(new Uint8Array(await crypto.subtle.digest("SHA-256",e))).map(r=>r.toString(16).padStart(2,"0")).join("")}async function N(t,e){return await K(t)===e}async function D(t){let e=t.headers.get("authorization");if(!e||!e.startsWith("Bearer "))throw Error("No token provided");let r=e.replace("Bearer ",""),o=await I(r,process.env.JWT_SECRET||"fallback-secret");if(!o.adminId||!o.username||!o.role)throw Error("Invalid token payload");return o}},E);export{J as __getNamedExports};
